<!DOCTYPE html>
<html lang="en" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="操作系统相当于软件和硬件之间的桥梁，屏蔽了硬件层的复杂性。核心部分是内核，本质上也是一个应用程序。\n概述\r基本功能\r进程管理 进程控制、进程同步、进程通信、死锁处理、处理机调度等。\n">
<title>操作系统</title>

<link rel='canonical' href='http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/'>

<link rel="stylesheet" href="/scss/style.min.b9c8156d464c343bdacaf14a871581fb94cbbdb9dd5cbce4ba017361187cc930.css"><meta property='og:title' content="操作系统">
<meta property='og:description' content="操作系统相当于软件和硬件之间的桥梁，屏蔽了硬件层的复杂性。核心部分是内核，本质上也是一个应用程序。\n概述\r基本功能\r进程管理 进程控制、进程同步、进程通信、死锁处理、处理机调度等。\n">
<meta property='og:url' content='http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/'>
<meta property='og:site_name' content=''>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2025-03-08T00:48:44&#43;08:00'/><meta property='article:modified_time' content='2025-03-08T00:48:44&#43;08:00'/>
<meta name="twitter:title" content="操作系统">
<meta name="twitter:description" content="操作系统相当于软件和硬件之间的桥梁，屏蔽了硬件层的复杂性。核心部分是内核，本质上也是一个应用程序。\n概述\r基本功能\r进程管理 进程控制、进程同步、进程通信、死锁处理、处理机调度等。\n">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu_cd3fd77b5cd603fc.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/"></a></h1>
            <h2 class="site-description">学会总结，学会复盘</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://blog.csdn.net/clpzn_?spm=1000.2115.3001.5343'
                        target="_blank"
                        title="CSDN"
                        rel="me"
                    >
                        
                        
                            <?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1741695404625" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8388" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M533.941 419.264c14.71-1.621 37.291-3.264 68.352-3.264 51.872 0 93.803 9.152 119.776 28.416 23.339 17.952 38.859 47.008 34.56 89.13-3.978 39.19-24.042 66.635-53.312 83.595C676.544 633.152 642.837 640 592.107 640c-29.888 0-58.422-1.643-80.107-4.896l21.941-215.84z m42.87 172.939c4.981 0.992 11.562 1.973 24.533 1.973 51.883 0 88.47-25.877 92.16-62.24 5.333-52.555-27.125-70.944-81.803-70.624-7.072 0-16.917 0-22.133 0.97L576.8 592.214h0.01z m223.498-164.704c210.955-39.872 229.163 31.776 222.646 95.189L1010.656 640h-66.944l11.21-106.987c2.422-23.562 17.505-69.653-55.338-67.914-25.184 0.608-37.707 4.064-37.707 4.064s-2.186 28.469-4.832 49.514L844.32 640h-65.653l13.024-119.573" fill="#231916" p-id="8389"></path><path d="M226.635 632.683c-12.374 4.341-38.038 7.317-73.91 7.317C49.6 640-6.048 590.933 0.523 526.09c7.893-77.28 90.336-120.757 180.618-120.757 34.976 0 55.552 2.859 74.859 7.638l-6.208 52.064c-12.821-4.384-42.89-8.406-67.232-8.406-53.141 0-98.25 16.043-103.424 66.763-4.608 45.355 27.061 67.04 86.816 67.04 20.8 0 51.477-3.019 65.653-7.37l-4.992 49.6 0.022 0.02z" fill="#C92027" p-id="8390"></path><path d="M272.715 580.021c19.285 6.763 59.488 13.504 92 13.504 35.029 0 54.528-9.333 56.096-23.797 1.418-13.205-12.928-14.987-52.491-24.01-54.667-12.897-89.547-32.843-86.133-64.705C286.176 443.99 337.685 416 416.725 416c38.56 0 75.915 2.613 95.275 8.715l-6.656 46.666c-12.565-4.202-60.672-10.037-93.205-10.037-32.992 0-50.07 9.973-51.254 20.917-1.493 13.846 15.659 14.486 58.528 25.451 58.027 14.155 83.403 34.09 80.086 64.992C495.605 609.109 449.259 640 356.715 640c-38.528 0-71.744-6.763-90.048-13.525l6.048-46.454z" fill="#231916" p-id="8391"></path></svg>
                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>Dark Mode</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">Table of contents</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#基本功能">基本功能</a></li>
    <li><a href="#用户态和内核态">用户态和内核态</a>
      <ol>
        <li><a href="#为什么需要分为两个态">为什么需要分为两个态</a></li>
      </ol>
    </li>
    <li><a href="#系统调用的过程">系统调用的过程</a></li>
  </ol>

  <ol>
    <li>
      <ol>
        <li><a href="#区别">区别</a></li>
      </ol>
    </li>
    <li><a href="#为什么有了进程还需要线程">为什么有了进程还需要线程</a></li>
    <li><a href="#为什么要使用多线程">为什么要使用多线程</a></li>
    <li><a href="#线程间的同步方式多个线程并发执行同步避免资源冲突">线程间的同步方式（多个线程并发执行，同步避免资源冲突）</a></li>
  </ol>

  <ol>
    <li><a href="#进程的状态">进程的状态</a></li>
    <li><a href="#进程间的通信方式ipc">进程间的通信方式IPC</a></li>
    <li><a href="#进程调度算法">进程调度算法</a></li>
    <li><a href="#僵尸进程和孤儿进程">僵尸进程和孤儿进程</a></li>
    <li><a href="#死锁">死锁</a>
      <ol>
        <li><a href="#死锁的四个必要条件">死锁的四个必要条件</a></li>
        <li><a href="#解决死锁的方法">解决死锁的方法</a></li>
        <li><a href="#1-预防"><strong>1. 预防</strong></a></li>
        <li><a href="#2避免"><strong>2.避免</strong></a></li>
        <li><a href="#3检测"><strong>3.检测</strong></a></li>
        <li><a href="#4解除"><strong>4.解除</strong></a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#内存碎片">内存碎片</a></li>
    <li><a href="#内存管理方式">内存管理方式</a>
      <ol>
        <li><a href="#1连续内存管理">1.连续内存管理</a></li>
        <li><a href="#2非连续内存管理">2.非连续内存管理</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li>
      <ol>
        <li><a href="#优点为什么要用">优点（为什么要用）</a></li>
        <li><a href="#逻辑虚拟地址和物理地址"><strong>逻辑(虚拟)地址和物理地址</strong></a></li>
        <li><a href="#分段机制">分段机制</a></li>
        <li><a href="#分页机制">分页机制</a></li>
        <li><a href="#多级页表"><strong>多级页表</strong></a></li>
        <li><a href="#块表">块表</a></li>
        <li><a href="#页缺失">页缺失</a></li>
        <li><a href="#页面置换算法">页面置换算法</a></li>
        <li><a href="#局部性原理">局部性原理</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#硬链接和软链接的区别">硬链接和软链接的区别</a></li>
    <li><a href="#硬链接为什么不能跨文件系统"><strong>硬链接为什么不能跨文件系统？</strong></a></li>
    <li><a href="#提高文件系统性能的方式">提高文件系统性能的方式</a></li>
    <li><a href="#常见的磁盘调度算法">常见的磁盘调度算法</a>
      <ol>
        <li><a href="#将数据从缓冲区读出写入磁盘这之间经历了几次复制"><strong>将数据从缓冲区读出写入磁盘，这之间经历了几次复制</strong></a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#linux文件系统">Linux文件系统</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="background-color: #B9A7CD; color: #fff;">
                操作系统
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Mar 08, 2025</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    21 minute read
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <p>操作系统相当于软件和硬件之间的桥梁，屏蔽了硬件层的复杂性。核心部分是内核，本质上也是一个应用程序。</p>
<h1 id="概述">概述
</h1><h2 id="基本功能">基本功能
</h2><ol>
<li>
<p>进程管理
进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p>
</li>
<li>
<p>内存管理
内存分配、地址映射、内存保护与共享、虚拟内存等。</p>
</li>
<li>
<p>文件管理
文件存储空间的管理、目录管理、文件读写管理和保护等。</p>
</li>
<li>
<p>设备管理
完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。
主要包括缓冲管理、设备分配、设备处理、虛拟设备等</p>
</li>
<li>
<p>网络管理</p>
<p>负责管理计算机网络的使用</p>
</li>
<li>
<p>安全管理</p>
<p>用户的身份认证，访问控制等</p>
</li>
</ol>
<h2 id="用户态和内核态">用户态和内核态
</h2><ul>
<li><strong>用户态(User Mode)</strong> : 用户态运行的进程可以直接读取用户程序的数据。用户态就是执行在用户空间中。 当需要调用操作系统提供的内核态级别功能时，需要系统调用</li>
<li><strong>内核态(Kernel Mode)</strong>：可以直接读取到计算机的任何资源，不受限制</li>
<li><strong>切换方法</strong>：
<ul>
<li>系统调用：用户主动请求切换到内核态，使用操作系统提供的接口。系统调用按照功能可以分为设备管理，文件管理，进程管理和内存管理。</li>
<li>中断：当外围设备完成时，发出中断请求，cpu需要暂停去执行中断信号。如果先前执行的指令是用户态下的，那么这个时候就发生了用户态到内核态的切换。</li>
<li>异常：当CPU执行用户态程序时，发生不可知的异常，就会切换到内核态</li>
</ul>
</li>
</ul>
<h3 id="为什么需要分为两个态">为什么需要分为两个态
</h3><p>有一些指令是比较危险的比如内存分配、设置时钟、IO 处理等，如果所有的程序都能使用这些指令的话，会对系统的正常运行造成灾难性地影响。需要限制这些危险指令只能内核态运行</p>
<p>如果计算机系统中<strong>只有一个内核态，那么所有程序或进程都必须共享系统资源</strong>，例如内存、CPU、硬盘等，这将导致系统资源的竞争和冲突，从而影响系统性能和效率。并且，这样也会让系统的安全性降低，毕竟所有程序或进程都具有相同的特权级别和访问权限。</p>
<h2 id="系统调用的过程">系统调用的过程
</h2><ol>
<li>用户态的程序发起系统调用，由于系统调用涉及一些特权指令，用户态程序权限不足，因此会中断执行（叫做Trap）</li>
<li>发生中断后，当前CPU执行的程序会中断，跳转到中断处理程序。内核程序开始执行，开始处理系统调用</li>
<li>内核处理完毕后，主动触发Trap，会再次发生中断。切换回用户态工作</li>
</ol>
<h1 id="进程和线程">进程和线程
</h1><p>进程是<strong>程序的一次运行，比如打开微信就是一个进程</strong></p>
<p>线程是<strong>进程的一个执行路径，比如微信进行里面有一个线程负责接收最新消息</strong></p>
<h3 id="区别">区别
</h3><p><strong>根本区别：进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位。</strong></p>
<p><strong>内存分配：<strong>同一进程的</strong>线程共享</strong>本进程的地址<strong>空间和资源</strong>，而<strong>进程之间</strong>的地址空间和资源是相互<strong>独立的</strong>。</p>
<p><strong>系统开销：<strong>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于</strong>创建或撤</strong>销线程时的<strong>开销</strong>。每个进程都有独立的代码和数据空间（程序上下文），<strong>程序之间的切换会有较大的开销</strong>；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），<strong>线程</strong>之间<strong>切换的开销小</strong>。线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p>
<p>**通信方面：**线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC</p>
<p><strong>包含关系</strong>：线程是进程划分成的更小的运行单位，一个进程在其执行的过程中可以产生多个线程。</p>
<p><strong>影响关系：<strong>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是</strong>一个线程崩溃可能导致整个进程都死掉</strong>。所以多进程要比多线程健壮。</p>
<h2 id="为什么有了进程还需要线程">为什么有了进程还需要线程
</h2><ol>
<li>资源开销方面</li>
<li>线程更轻量级，一个进程可以创建多个线程</li>
<li>线程可以并发处理，进程不可以</li>
<li>进程通信需要借助PIC，同一进程之间的线程通信无需调用内核（因为共享内存和文件）</li>
</ol>
<h2 id="为什么要使用多线程">为什么要使用多线程
</h2><ol>
<li>线程轻量级，且所需要的系统开销小</li>
<li>实现高并发</li>
<li>单核时代，多线程为了提高进程利用cpu和io系统的效率，如果一个进程只有一个线程，一个线程被阻塞整个进程都被阻塞，这样不能同时利用cpu和io系统</li>
<li>多核时代，多线程为了提高进程利用多核cpu的能力，不同线程利用不同cpu</li>
</ol>
<h2 id="线程间的同步方式多个线程并发执行同步避免资源冲突">线程间的同步方式（多个线程并发执行，同步避免资源冲突）
</h2><ul>
<li><strong>互斥锁(Mutex)</strong> ：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 <code>synchronized</code> 关键词和各种 <code>Lock</code> 都是这种机制。</li>
<li><strong>读写锁（Read-Write Lock）</strong> ：允许<strong>多个线程同时读</strong>取共享资源，但只有<strong>一个线程</strong>可以对共享资源进行<strong>写操作</strong>。</li>
<li><strong>信号量(Semaphore)</strong> ：它允许同一时刻<strong>多个线程访问同一资源</strong>，但是需要控制同一时刻访问此资源的<strong>最大线程数量</strong>。</li>
<li><strong>屏障（Barrier）</strong> ：屏障是一种同步原语，用于等待多个线程到达某个点再一起继续执行。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都到达屏障后，它们才会一起继续执行。比如 Java 中的 <code>CyclicBarrier</code> 是这种机制。</li>
<li><strong>事件(Event)</strong> :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>
</ul>
<h1 id="pcb">PCB
</h1><p>**进程控制块，**是操作系统用来管理和跟踪进程的数据结构，每个进程对应一个独立PCB。</p>
<p>包含内容：进程的描述信息（进程名字，标识符等），进程的调度信息，包括阻塞原因，进程状态，进程优先级。进程对资源的需求情况（cpu时间，内存空间）。进程打开的文件信息</p>
<h2 id="进程的状态">进程的状态
</h2><ul>
<li><strong>创建状态(new)</strong>：进程正在被创建。</li>
<li><strong>就绪状态(ready)</strong>：进程获得了所需资源，等待<strong>处理器分配的时间片</strong>。</li>
<li><strong>运行状态(running)</strong>：进程正在<strong>处理器</strong>上运行。</li>
<li><strong>阻塞状态(waiting)</strong>：又称为等待状态，进程正在等<strong>待某资源为可用</strong>或<strong>IO 操作完成</strong>。即使处理器空闲，该进程也不能运行。</li>
<li><strong>结束状态(terminated)</strong>：<strong>进程正常结束</strong>或其他原因<strong>中断退出运行</strong>。</li>
</ul>
<p><img src="/img/image.png"
	
	
	
	loading="lazy"
	
	
></p>
<h2 id="进程间的通信方式ipc">进程间的通信方式IPC
</h2><ol>
<li><strong>管道/匿名管道(Pipes)</strong> ：用于<strong>父子进程间</strong>或者<strong>兄弟进程之间</strong>的通信。管道其实就是<strong>内核中的缓存</strong>，从一端写入，另一端读取数据。</li>
<li><strong>有名管道(Names Pipes) :<strong>为了克服管道的缺点（只能在有关系的进程间通信），提出了有名管道。有名管道严格遵循</strong>先进先出</strong>(first in first out)。有名管道以<strong>磁盘文件的方式存在</strong>，可以实现本机任意两个进程通信。管道的特点是<strong>使用简单，缺点是通信方式效率低</strong>。</li>
<li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li>
<li><strong>消息队列(Message Queuing)</strong> ：消息队列面向记录，可以独立于读写进程存在。消息队列存放在内核中，只有在内核重启或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。消息队列不适合比较大的数据传输，因为每个消息体有最大长度限制。消息队列通信的过程中，存在用户态到内核态之间的数据拷贝开销。因为写入数据的时候会发生用户态到内核态之间的转换。读数据的时候，会发生内核态到用户态转换的过程。</li>
<li><strong>共享内存(Shared memory)</strong> ：多个进程访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如<strong>互斥锁</strong>和<strong>信号量</strong>等。可以说这是最有用的进程间通信方式。</li>
<li><strong>信号量(Semaphores)</strong> ：用了共享内存通信，为了防止多线程进行资源，需要一个保护机制，所以引入了信号量。信号量是一个<strong>计数器，<strong>有两个原子操作即</strong>p，v操作</strong> 。P操作信号量减去 -1，相减后如果信号量**&lt;0**，则表明资源已被占用，进程<strong>需阻塞等待</strong>；相减后如果信号量**&gt;=0**，则表明还有资源可使用，进程可正常<strong>继续执行</strong>。V操作，信号量加上 1，相加后如果信号量&lt;= 0，则表明当前有阻塞中的进程，于是会将该进程<strong>唤醒运行</strong>；相加后如果信号量&gt;0，则表明当前没有阻塞中的进程。P 操作是用在<strong>进入共享资源之前</strong>，V操作是用在离开<strong>共享资源之后</strong>，这两个操作是必须成对出现的</li>
<li><strong>套接字(Sockets)</strong> : 前面提到方法都是在同一台主机上进行进程间通信，那要想跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。 此方法主要用于在客户端和服务器之间通过网络进行通信。客户端创建一个socket对象，绑定服务器ip和端口。服务器创建一个serberSocket，监听端口。服务端接收请求时就响应请求。</li>
</ol>
<h2 id="进程调度算法">进程调度算法
</h2><p><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，优点<strong>简单易实现，缺点是平均等待时间较长。</strong></p>
<p><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中<strong>选出一个估计运行时间最短的进程为之分配资源</strong>，<strong>缺点是可能导致长作业饿死，并且需要知道下一个进程的执行时间。</strong></p>
<p><strong>时间片轮转调度算法</strong> : ，<strong>将CPU时间划分成一个个的时间片（time slice）</strong>，为就绪队列中的<strong>进程依次轮流分配一个时间片的CPU</strong>。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系： 如果<strong>时间片太小</strong>，会导致进程<strong>切换得太频繁</strong>，在进程切换上就会花过多时间。而如果<strong>时间片过长</strong>，那么<strong>实时性就不能得到保证</strong></p>
<p><strong>优先级调度</strong> ： 从就绪队列中选择<strong>优先级最高的进程</strong>为之分配资源，具有相同优先级的进程以先到先服务的方式执行。<strong>低优先级的进程可能被饿死。</strong></p>
<p><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使<strong>高优先级的作业得到响应又能使短作业（进程）迅速完成</strong>。因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。具体做法：将就绪队列拆分成若干个，不用的就绪队列采用不同的调度算法。对于优先级低的队列用时间片轮转方法。其他队列遵循先到先服务。<strong>按照队列优先级调度，首先调度最优优先级队列的进程</strong>。</p>
<h2 id="僵尸进程和孤儿进程">僵尸进程和孤儿进程
</h2><p><strong>僵尸进程</strong>：<strong>子进程已经终止，但是其父进程仍在运行</strong>，且父进程没有调用 wait()或 waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，导致<strong>子进程的 PCB 依然存在于系统中</strong>，但无法被进一步使用。这种情况下，子进程被称为“僵尸进程”。避免僵尸进程的产生，父进程需要及时调用 <strong>wait()或 waitpid()系统调用来回收子进程。</strong></p>
<p><strong>孤儿进程</strong>：一个进程的<strong>父进程已经终止或者不存在</strong>，但是该进程仍在运行。这种情况下，该进程就是孤儿进程。为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为 init 进程（进程号为 1），由 <strong>init 进程</strong>来回收孤儿进程的资源。</p>
<p><strong>查找僵尸进程</strong></p>
<p>top命令 zombie表示僵尸进程的数量</p>
<h2 id="死锁">死锁
</h2><p>多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。比如两个进程A,B，进程 A 占用资源 X 并且请求资源 Y，而进程 B 已经占用了资源 Y 并请求资源 X。两个进程都在等待对方释放资源，无法继续执行，陷入了死锁状态。</p>
<h3 id="死锁的四个必要条件">死锁的四个必要条件
</h3><ul>
<li><strong>互斥</strong>：<strong>资源必须处于非共享模式</strong>，即一次只有一个进程可以使用。</li>
<li><strong>占有并等待</strong>：经得到了某个资源的进程可以再请求新的资源。</li>
<li><strong>非抢占</strong>：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li>
<li><strong>循环等待</strong>：有一组等待进程 <code>{P0, P1,..., Pn}</code>， <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，……，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</li>
</ul>
<p>同时满足这四个条件不一定发生死锁</p>
<h3 id="解决死锁的方法">解决死锁的方法
</h3><h3 id="1-预防"><strong>1. 预防</strong>
</h3><p>是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间上都不满足</p>
<p>破坏死锁产生的四个必要条件的其中之一，主要是<strong>破坏占有并等待，和循环等待</strong>。</p>
<p><strong>1、静态分配策略</strong></p>
<p>是指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。缺点：降低资源的利用率，有些资源后续才使用，可能导致一个进程占用了一些几乎不用的资源而使得其他需要该资源的进程产生等待。</p>
<p><strong>2、层次分配策略</strong></p>
<p>将资源分为多个层次，一个进程得到某一层的一个资源后，只能再申请较高一层的资源。释放的时候，需要先释放高层资源。这样就不会出现循环等待、</p>
<h3 id="2避免"><strong>2.避免</strong>
</h3><p>则是系统在分配资源时，根据资源的使用情况<strong>提前做出预测</strong>，从而<strong>避免死锁的发生</strong></p>
<p>允许四个条件出现，但是根据系统状态（安全和不安全）在分配资源的时候判断是否安全，安全才可以分配。</p>
<p><strong>银行家算法：在分配资源前，<strong>会检查是否</strong>存在一个安全序列，能够</strong>依次满足<strong>所有进程完成。</strong></p>
<h3 id="3检测"><strong>3.检测</strong>
</h3><p>是指系统设有<strong>专门的机构</strong>，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。类似乐观锁的思想，等发生了再去解决。可利用<strong>进程-资源分配图</strong>检测系统是否处于死锁。</p>
<p>用一个方框表示每一个资源类，方框中的黑点表示该资源类中的各个资源，用一个圆圈表示每一个进程，用 <strong>有向边</strong> 来表示<strong>进程申请资源和资源被分配的情况</strong>。</p>
<p>死锁检测算法是通过<strong>检测有向图是否存在环来实现</strong>，从一个节点出发进<strong>行深度优先搜索</strong>，<strong>对访问过的节点进行标记，如果访问了已经标记的节点</strong>，就表示有向图存在环，也就是检测到死锁的发生。</p>
<h3 id="4解除"><strong>4.解除</strong>
</h3><p>是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong>。、</p>
<p><strong>立即结束所有进程的执行</strong>，重新启动操作系统 ：这种方法简单，但以前所在的工作全部作废，损失很大。</p>
<p><strong>撤销涉及死锁的所有进程</strong>，<strong>解除死锁后继续运行</strong>：这种方法能彻底打破死锁的循环等待条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。</p>
<p><strong>逐个撤销涉及死锁的进程</strong>，回收其资源直至死锁解除。</p>
<p><strong>抢占资源</strong>：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除</p>
<h1 id="内存管理">内存管理
</h1><p>负责内存的分配与回收</p>
<p>地址转换：将虚拟地址转换为内存中的物理地址</p>
<p>内存扩充：没有足够的内存时，利用虚拟内存技术</p>
<h2 id="内存碎片">内存碎片
</h2><p>在内存的申请和释放过程中产生的，通常分为下面两种</p>
<p>**内部内存碎片(Internal Memory Fragmentation，简称为内存碎片)：已经分配给进程使用但是未被使用的内存。**产生原因是分配的时候采用固定比例，分配的内存大于需要的空间。</p>
<p><strong>外部内存碎片(External Memory Fragmentation，简称为外部碎片)</strong>：内存中较小的内存块，无法满足一个进程的需求</p>
<p><img src="/img/image%201.png"
	
	
	
	loading="lazy"
	
		alt="/img/image.png"
	
	
></p>
<h2 id="内存管理方式">内存管理方式
</h2><h3 id="1连续内存管理">1.连续内存管理
</h3><p>为一个用户程序分配一个连续的内存空间</p>
<p><strong>块式管理</strong></p>
<p><strong>将内存按固定块划分</strong>，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块。linux中为了解决外部碎片问题，采用伙伴系统算法实现，思想是内存按照2的幂次方分配，将相邻的内存组成一对伙伴。当进行内存分配时，伙伴系统会尝试找到大小最合适的内存块。如果找到的内存块过大，就将其一分为二，分成两个大小相等的伙伴块。如果还是大的话，就继续切分，直到到达合适的大小为止。假设两块相邻的内存块都被释放，系统会将这两个内存块合并，进而形成一个更大的内存块</p>
<p>缺点：容易造成内部碎片。</p>
<ol>
<li><strong>固定分区分配</strong>（使用分区使用表）
分区大小相等（缺乏灵活性，造成内存空间浪费）
分区大小不等</li>
<li><strong>动态分区分配/可变分区分配</strong>（数据结构：空闲分区表或空闲分区链）
存储保护：重定位寄存器（基址寄存器和限长寄存器）：对内存的访问进行保护
基址寄存器：记录进程在内存中的起始物理地址
限长寄存器：记录进程逻辑地址长度
<strong>动态分区分配算法</strong>
<strong>首次适应（First Fit）</strong>：从头开始找到的第一个足够大的分区（执行最快）。对空闲表项地址从大到小排列。
<strong>循环首次适应（Next Fit）</strong>：首次适应的变种，从上次找到的位置继续往下找，找到的第一个足够大的分区
<strong>最佳适应（Best Fit）</strong>：搜索所有可用分区，找到的足够大但却最小的分区.要求所有空闲分区按其容量从小到大顺序形成空闲分区链。这样找到的第一个就满足。（很多碎片）
<strong>最差适应（Worst Fit</strong>）：搜索所有可用分区，找到的最大的分区。（减少碎片）
<strong>回收内存</strong>
（1）前面有空闲区，则合并，不必为回收分区分配新表项，只需修改前面分区的大小
（2）后面有空闲区，则合并，使用回收区首址作为新空闲区首址
（3）前面后面都有空闲区，则合并，使用前面的表项和首址，取消后面的表项
（4）前面后面都没有空闲区，则合并，为回收分区分配新表项碎片</li>
</ol>
<h3 id="2非连续内存管理">2.非连续内存管理
</h3><p>允许一个程序使用内存分布在不相邻的内存中。</p>
<p><strong>段式管理</strong></p>
<p>以段(一段连续的物理内存)的形式管理/分配物理内存。段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过<strong>段表</strong>对应<strong>逻辑地址和物理地址。</strong></p>
<p>缺点：导致内存外部碎片。 因为段和段之间容易留下空间无法使用</p>
<p><strong>页式管理</strong></p>
<p><strong>把内存分为大小相等且固定的一页一页的形式</strong>，页较小，相对相比于<strong>块式管理的划分力度更大</strong>，提高了内存利用率，减少了碎片。任意的虚拟页可以被映射到物理内存呢中的任意物理页上</p>
<p>逻辑地址=页号+业内地址  物理地址=快号+业内地址</p>
<p>没有外碎片，有内碎片</p>
<p><strong>段页式管理</strong></p>
<p>页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求</p>
<p>段页式管理：把内存分成若干段，每个段分成若个页</p>
<p><strong>分页机制和分段机制有哪些共同点和区别呢？</strong></p>
<ul>
<li>
<p>共同点 ：</p>
<p>分页机制和分段机制都是为了提高内存利用率，减少内碎片。</p>
<p>页和段都是<strong>离散存储</strong>的，属于非连续存储管理。</p>
</li>
<li>
<p>区别 ：</p>
<p><strong>页是物理单位</strong>，即操作系统<strong>将物理内存划分成固定大小的页面</strong>，每个页面的大小通常是 2 的幂次方。段则是逻辑单位，是为了满足<strong>程序</strong>对内存空间的逻辑需求而设计的，根据程序中的数据和代码的逻辑结构来划分。</p>
<p><strong>页的大小是固定的</strong>，由操作系统决定；而<strong>段的大小不固定</strong>，取决于我们当前运行的程序。</p>
<p><strong>分段机制容易出现外部内存碎片，分页机制解决了外部内存碎片问题</strong>，但是仍然可能出现内部内存碎片。</p>
</li>
</ul>
<h1 id="虚拟内存">虚拟内存
</h1><p>虚拟内存是指逻辑上存在，是假象的，主要作用是为进程访问主存（物理内存）的桥梁并简化内存管理</p>
<h3 id="优点为什么要用">优点（为什么要用）
</h3><ol>
<li><strong>隔离进程。每个进程都有对应的虚拟地址空间，进程之间彼此隔离</strong></li>
<li>提升物理内存利用率。操作系统只需要将当前进程正在使用的部分数据载入物理内存</li>
<li>简化内存管理。不用和真正物理内存打交道，而是借组虚拟地址空间访问</li>
<li>实现多个进程共享物理内存。</li>
<li>提高内存使用的安全性：控制进程对物理内存的访问，避免造成系统崩溃</li>
<li>提供更大的可使用内存空间：物理内存不够的时候，可以利用磁盘充当。将物理内存页保存到磁盘，就是读写速度会慢一点。</li>
</ol>
<h3 id="逻辑虚拟地址和物理地址"><strong>逻辑(虚拟)地址和物理地址</strong>
</h3><p>物理地址指真实物理内存的中的地址，也就是<strong>内存地址寄存器</strong>的地址。物理地址的集合叫物理地址空间。</p>
<p>逻辑地址：比如说在程序中某个对象在堆上的地址。虚拟内存地址的集合叫虚拟地址空间。逻辑地址包括<strong>段基地址</strong>（在内存中的起始位置）和<strong>偏移地址</strong>（距离段基地址的偏移量）
为什么需要有两个地址？<strong>逻辑地址可以让地址分配更加灵活，比如逻辑地址中连续的地址可以在物理地址中不连续。</strong></p>
<p>将虚拟地址翻译成物理地址的主要机制有：<strong>分段机制和分页机制和段页机制</strong></p>
<h3 id="分段机制">分段机制
</h3><p>通过<strong>段表</strong>映射虚拟地址和物理地址</p>
<p>虚拟地址由两部分组成：<strong>段号，段内偏移量</strong>。</p>
<p>具体地址翻译过程如下：首先解析得到虚拟地址的段号，然后在段表中根据段号找到该段的起始地址。该段的起始地址加上段内偏移量得到最终的物理地址。</p>
<p><img src="/image%202.png"
	
	
	
	loading="lazy"
	
		alt="image.png"
	
	
></p>
<p>段表中还有段长（检查虚拟地址是否超出合法范围），段类型等信息</p>
<p>通过段号不一定可以找到对应的段表项目。</p>
<h3 id="分页机制">分页机制
</h3><p>通过<strong>页表</strong>映射。</p>
<p>虚拟地址由两部分组成：<strong>页号，页内偏移量。</strong></p>
<p>具体地址翻译过程如下：首先解析得到虚拟地址的页号号，然后在页表中根据页号找到该页的起始地址。该页的起始地址加上页内偏移量得到最终的物理地址。</p>
<p><img src="/image%203.png"
	
	
	
	loading="lazy"
	
		alt="image.png"
	
	
></p>
<p>页表中号存储如访问标志（标志该页面有没有被访问过）等信息</p>
<h3 id="多级页表"><strong>多级页表</strong>
</h3><p>为了避免把全部页表一直放在内存中占用过多空间，可以压缩页表占用的内存。</p>
<p>比如说二级页表，一级页表项可以覆盖更大的范围，然后一个页表项再对应二级页表项。那么如果某一个一级页表项用不到，就不创建它对应的二级页表项。</p>
<p>多级页表属于时间换空间，增加页表查询的次数减少页表的占用空间</p>
<h3 id="块表">块表
</h3><p><strong>为了解决虚拟地址到物理地址的转换速度，<strong>操作系统在 页表方案 基础之上引入了 快表
可以理解为一种特殊的</strong>高速缓冲存储器</strong>（Cache），缓存了虚拟页号到物理页号的映射关系。</p>
<p>使用快表之后的地址转换流程是这样的：
根据虚拟地址中的页号查<strong>快表</strong>；
如果该页在快表中，直接从快表中读取相<strong>应的物理地址</strong>；
如果该页不在快表中，就访问<strong>内存中的页表</strong>，再从页表中得到物理地址，同时将<strong>页表中的该映射表项添加到快表中；</strong>
当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</p>
<p>由于页表也在主存中，因此在没有块表的时候，需要访问两次主存。</p>
<h3 id="页缺失">页缺失
</h3><p><strong>硬性页缺失（Hard Page Fault）</strong>：物理内存中没有对应的物理页。会从磁盘文件中加载相应的内容到物理内存中。
<strong>软性页缺失（Soft Page Fault）</strong>：物理内存中有对应的物理页，但虚拟页还未和物理页建立映射。</p>
<h3 id="页面置换算法">页面置换算法
</h3><ul>
<li><strong>最佳页面置换算法（OPT，Optimal）</strong>：优先选择淘汰的页面是**以后永不使用的，<strong>或者是</strong>在最长时间内不再被访问的页面，**这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现，只是理论最优的页面置换算法，可以作为衡量其他置换算法优劣的标准。</li>
<li><strong>先进先出页面置换算法（FIFO，First In First Out）</strong> : 最简单的一种页面置换算法，总是<strong>淘汰最先进入内存的页面</strong>，即选择在内存中驻留时间最久的页面进行淘汰。（<strong>经常访问或者需要长期存在的页面会被频繁调入调出）</strong></li>
<li><strong>最近最久未使用页面置换算法（LRU ，Least Recently Used）</strong>：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。（使用最多）</li>
<li><strong>最少使用页面置换算法（LFU，Least Frequently Used）</strong> : 和 LRU 算法比较像，不过该置换算法选择的<strong>是之前一段时间内使用最少的页面</strong>作为淘汰页。</li>
<li><strong>时钟页面置换算法（Clock）</strong>：可以认为是一种最近未使用算法，即逐出的页面都是最近没有使用的那个。</li>
</ul>
<h3 id="局部性原理">局部性原理
</h3><p>局部性原理是指在程序执行过程中，数据和指令的访问存在一定的空间和时间上的局部性特点。其中，时间局部性是指一个数据项或指令在<strong>一段时间内被反复使用</strong>的特点，空间局部性是指一个数据项或指令在一段时间内<strong>与其相邻的数据项或指令被反复</strong>使用的特点。</p>
<p>在分页机制中，页表的作用是将虚拟地址转换为物理地址，从而完成内存访问。在这个过程中，局部性原理的作用体现在两个方面：</p>
<ul>
<li><strong>时间局部性</strong>：由于程序中<strong>存在一定的循环或者重复操作</strong>，因此会<strong>反复访问同一个页或一些特定</strong>的页，这就体现了时间局部性的特点。为了利用<strong>时间局部性</strong>，分页机制中通常采<strong>用缓存机制来</strong>提高页面的命中率，即将<strong>最近访问过的</strong>一些页放入缓存中，如果下一次访问的页已经在缓存中，就不需要再次访问内存，而是直接从缓存中读取。</li>
<li><strong>空间局部性</strong>：由于程序中数据和指令的访问通常是具有一定的空间连续性的，因此<strong>当访问某个页时，往往会顺带访问其相邻的一些页</strong>。为了利用空间局部性，分页机制中通常采用预取技术来<strong>预先将相邻的一些页读入内存缓存中</strong>，以便在未来访问时能够直接使用，从而提高访问速度。</li>
</ul>
<h1 id="文件系统">文件系统
</h1><p>主要负责管理和组织计算机存储设备上的文件和目录，</p>
<ol>
<li><strong>存储管理</strong>：将文件数据存储到物理存储介质中，并且管理空间分配，以确保每个文件都有足够的空间存储，并避免文件之间发生冲突。</li>
<li><strong>文件管理</strong>：文件的创建、删除、移动、重命名、压缩、加密、共享等等。</li>
<li><strong>目录管理</strong>：目录的创建、删除、移动、重命名等等。</li>
<li><strong>文件访问控制</strong>：管理不同用户或进程对文件的访问权限，以确保用户只能访问其被授权访问的文件，以保证文件的安全性和保密性</li>
</ol>
<h2 id="硬链接和软链接的区别">硬链接和软链接的区别
</h2><h2 id="硬链接为什么不能跨文件系统"><strong>硬链接为什么不能跨文件系统？</strong>
</h2><h2 id="提高文件系统性能的方式">提高文件系统性能的方式
</h2><h2 id="常见的磁盘调度算法">常见的磁盘调度算法
</h2><ol>
<li>
<p>先来先服务</p>
<p>按照磁盘请求的顺序进行调度。简单公平，平均寻道时间较长</p>
</li>
<li>
<p>最短寻道时间优先</p>
<p>优先调度与当前磁头所在磁道距离最近的磁道。
虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p>
</li>
</ol>
<h3 id="将数据从缓冲区读出写入磁盘这之间经历了几次复制"><strong>将数据从缓冲区读出写入磁盘，这之间经历了几次复制</strong>
</h3><p><img src="/image%204.png"
	
	
	
	loading="lazy"
	
		alt="image.png"
	
	
></p>
<p>第一次拷贝，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。
第二次拷贝，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。
第三次拷贝，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。
第四次拷贝，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</p>
<p>会经历4次上下文切换，2次CPU拷贝，2次DMA拷贝
上下文切换：当用户程序向内核发起系统调用时，CPU 将用户进程从用户态切换到内核态；当系统调用返回时，CPU 将用户进程从内核态切换回用户态。
CPU拷贝：由 CPU 直接处理数据的传送，数据拷贝时会一直占用 CPU 的资源。
DMA拷贝：由 CPU 向DMA磁盘控制器下达指令，让 DMA 控制器来处理数据的传送，数据传送完毕再把信息反馈给 CPU，从而减轻了 CPU 资源的占有率。</p>
<p>但是有时候用户并不会对数据进行加工，所以没必要将数据拷贝到用户缓冲区。也就有一种新技术：零拷贝</p>
<p>零拷贝的实现：（优化技术）
①mmap+write</p>
<p><img src="/image%205.png"
	
	
	
	loading="lazy"
	
		alt="image.png"
	
	
></p>
<p>具体过程如下:
1.应用进程调用了 mmap()后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共
享」这个缓冲区;
2.应用进程再调用 write()，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由
CPU 来搬运数据;
3.最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。
我们可以得知，通过使用 mmap() 来代替 read()， 可以减少一次数据拷贝的过程。</p>
<h1 id="linux">Linux
</h1><h2 id="linux文件系统">Linux文件系统
</h2><p>一切被操作系统管理的资源都被视为文件。这种设计使得 Linux 系统可以通过统一的文件接口来管理和操作不同类型的资源，从而实现了一种统一的文件操作方式。</p>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2025 clp
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.30.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.a32e1d830de39b4f54beb818df5fa0fd0b5d098155f1ee7fb4f5cee4d313bb2a.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
